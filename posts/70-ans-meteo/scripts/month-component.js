/**
 * Generates CSS code for a background color cycling animation.
 *
 * @param {string[]} colors - An array of valid CSS color strings (e.g., ['red', '#00ff00', 'rgba(0,0,255,0.5)']). Must contain at least two colors.
 * @param {object} [options={}] - Optional configuration object.
 * @param {string} [options.animationName='bgColorCycle'] - The name for the CSS @keyframes rule and animation.
 * @param {string} [options.selector='.color-cycle-element'] - The CSS selector for the element(s) to apply the animation to.
 * @param {number} [options.durationPerStep=3] - The duration (in seconds) for the transition between each color step. The total animation duration will be colors.length * durationPerStep.
 * @param {string} [options.timingFunction='linear'] - The animation-timing-function CSS value (e.g., 'linear', 'ease-in-out').
 *
 * @returns {string} A string containing the generated CSS code (@keyframes and the rule applying the animation), or an empty string if input is invalid.
 */
function generateColorCycleCss(colors, options = {}) {
  // --- Input Validation ---
  if (!Array.isArray(colors) || colors.length < 2) {
    console.error(
      "generateColorCycleCss requires an array of at least two colors.",
    );
    return ""; // Return empty string for invalid input
  }

  // --- Set Defaults and Options ---
  const {
    animationName = "bgColorCycle",
    selector = ".color-cycle-element",
    durationPerStep = 1, // seconds per color transition
    timingFunction = "linear",
  } = options;

  const numColors = colors.length;
  const totalDuration = numColors * durationPerStep; // Total animation cycle duration

  // --- Build @keyframes Rule ---
  let keyframes = `@keyframes ${animationName} {\n`;
  const stepPercentage = 100 / numColors; // Percentage duration for each color stage

  for (let i = 0; i < numColors; i++) {
    const percentage = (i * stepPercentage).toFixed(2); // Calculate percentage for this keyframe
    keyframes += `  ${percentage}% {\n`;
    keyframes += `    background-color: ${colors[i]};\n`;
    keyframes += `  }\n`;
  }

  // Add the final keyframe (100%) to explicitly transition back to the first color
  // for a smooth loop.
  keyframes += `  100% {\n`;
  keyframes += `    background-color: ${colors[0]};\n`;
  keyframes += `  }\n`;
  keyframes += `}\n\n`; // Close @keyframes rule

  // --- Build CSS Rule to Apply the Animation ---
  let cssRule = `/* CSS generated by generateColorCycleCss */\n`;
  cssRule += `/* Apply this class (or the selector you provided) to the HTML element */\n`;
  cssRule += `${selector} {\n`;
  // Set initial background color to prevent flashing before animation starts
  cssRule += `  background-color: ${colors[0]};\n`;
  // Animation properties using the 'animation' shorthand
  cssRule += `  animation: ${animationName} ${totalDuration}s ${timingFunction} infinite;\n`;

  cssRule += `}\n`;

  // --- Combine and Return ---
  return keyframes + cssRule;
}

class MonthCalendar extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
  }

  connectedCallback() {
    // Default to current month and year if not provided
    this.year = this.getAttribute("year") || new Date().getFullYear();
    this.month = this.getAttribute("month") || new Date().getMonth() + 1; // Month is 1-12 for users
    this.color = this.getAttribute("color") || "avg_temps";

    this.render();
  }

  static get observedAttributes() {
    return ["year", "month", "color"];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (name === "year") {
        this.year = newValue;
      } else if (name === "month") {
        this.month = newValue;
      } else if (name === "color") {
        this.color = newValue;
      }
      this.render();
    }
  }

  getDaysInMonth(year, month) {
    // month parameter is 1-12 but Date expects 0-11
    return new Date(year, month, 0).getDate();
  }

  getFirstDayOfMonth(year, month) {
    // Get day of week (0-6, Sunday-Saturday) for the first day
    let day = new Date(year, month - 1, 1).getDay();
    // Convert to Monday-based (0-6, Monday-Sunday)
    return day === 0 ? 6 : day - 1;
  }

  getLastDayOfMonth(year, month) {
    // Get day of week (0-6, Sunday-Saturday) for the first day of the next month
    let day = new Date(year, month, 0).getDay();
    // Get previous day and convert to Monday-based (0-6, Monday-Sunday)
    return day === 0 ? 6 : day - 1;
  }

  render() {
    // Convert string attributes to numbers
    const year = parseInt(this.year);
    const month = parseInt(this.month);

    // Get month name for header
    const month_list = [
      "janvier",
      "février",
      "mars",
      "avril",
      "mai",
      "juin",
      "juillet",
      "août",
      "septembre",
      "octobre",
      "novembre",
      "décembre",
    ];
    const monthName = month_list[month - 1];

    // Calculate calendar details
    const daysInMonth = this.getDaysInMonth(year, month);
    const firstDayOfMonth = this.getFirstDayOfMonth(year, month);
    const lastDayOfMonth = this.getLastDayOfMonth(year, month);

    // Create HTML for the calendar
    let styles = `
      :host {
        display: block;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }
      .calendar {
        width: 100%;
        height: 100%;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        background-color: #f7f7f7;
      }
      .header {
        padding: 10px;
        text-align: center;
        font-weight: bold;
      }
      .days {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
      }
      .day {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;

        background-color: white;
        font-size: 0.7em;
        text-align: center;
      }
      .day:nth-child(7n) {
        border-right: none;
      }
      .day.empty {
        background-color: #f7f7f7;
      }

      .showPopup {
        cursor: pointer;
      }

      .hasRecords {
        border: 1px solid black;
      }

      .year-header {
        color: gray;
      }

      .toggle-year-header {
        display: none;
      }
    `;

    // Create days
    let daysHTML = "";

    // Empty cells for days before the start of the month
    for (let i = 0; i < firstDayOfMonth; i++) {
      daysHTML += `<div class="day empty"></div>`;
    }

    // Get current date for highlighting today
    const today = new Date();
    const isCurrentMonth =
      today.getFullYear() === year && today.getMonth() === month - 1;
    const currentDay = today.getDate();

    // Actual days of the month
    for (let day = 1; day <= daysInMonth; day++) {
      const dataAndDev = getDayDataAndDev(year, month, day);
      if (dataAndDev[this.color] === undefined) {
        console.log({ year, month, day, color: this.color });
        console.log(dataAndDev);
      }
      const bgColor = colorInterpolators[this.color](
        dataAndDev[this.color]["dev"],
      );
      daysHTML += `<div data-date="${year}-${month}-${day}" class="day showPopup ${hasRecords(year, month, day) ? "hasRecords" : ""} day-${day}" style="background-color: ${bgColor}">${day}</div>`;
    }

    // Empty cells for days after the end of the month
    for (let i = lastDayOfMonth + 1; i < 7; i++) {
      daysHTML += `<div class="day empty"></div>`;
    }

    // Render the complete calendar
    this.shadowRoot.innerHTML = `
      <style>${styles}</style>
      <div class="calendar">
        <div class="header">${monthName} <span class="year-header ${month == 1 ? "" : "toggle-year-header"}">${year}</span></div>
        <div class="days">${daysHTML}</div>
      </div>
    `;
  }
}

// Define the new element
customElements.define("month-calendar", MonthCalendar);
